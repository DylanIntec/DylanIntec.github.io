<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Name Sign Editor</title>
    <style>
        body {
            margin: 0;
            display: flex;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        #viewer {
            flex: 2;
            background-color: #f0f0f0;
        }
        #options {
            flex: 1;
            padding: 20px;
            background-color: #ffffff;
            overflow-y: auto;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        }
        .option-group {
            margin-bottom: 20px;
        }
        .option-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .option-group input[type="number"],
        .option-group select,
        .option-group input[type="color"],
        .option-group input[type="text"] {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        #exportBtn {
            width: 100%;
            padding: 10px;
            background-color: #4287f5;
            color: #ffffff;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        #exportBtn:hover {
            background-color: #306bd0;
        }
    </style>
</head>
<body>
    <!-- 3D Viewer -->
    <div id="viewer"></div>

    <!-- Options Panel -->
    <div id="options">
        <div class="option-group">
            <label for="baseWidth">Baseplate Width (mm)</label>
            <input type="number" id="baseWidth" value="140" min="50" max="300">
        </div>
        <div class="option-group">
            <label for="baseHeight">Baseplate Height (mm)</label>
            <input type="number" id="baseHeight" value="45" min="20" max="150">
        </div>
        <div class="option-group">
            <label>
                <input type="checkbox" id="showHoles" checked>
                Mounting Holes
            </label>
        </div>
        <div class="option-group">
            <label for="holeSpacing">Hole Spacing (mm)</label>
            <input type="number" id="holeSpacing" value="112" min="20" max="250" step="1">
        </div>
        <div class="option-group">
            <label for="baseColor">Baseplate Color</label>
            <select id="baseColor">
                <option value="#0088FF" selected>Blue</option>
                <option value="#FF0000">Red</option>
                <option value="#000000">Black</option>
                <option value="#FFFFFF">White</option>
            </select>
        </div>
        <div class="option-group">
            <label for="borderColor">Border & Text Color</label>
            <select id="borderColor">
                <option value="#FFFFFF" selected>White</option>
                <option value="#FF0000">Red</option>
                <option value="#000000">Black</option>
                <option value="#0088FF">Blue</option>
            </select>
        </div>
        <div class="option-group">
            <label for="signText">Sign Text</label>
            <input type="text" id="signText" placeholder="Enter your name">
        </div>
        <div class="option-group">
            <label for="fontPicker">Font</label>
            <select id="fontPicker">
                <option value="Arial">Arial</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Verdana">Verdana</option>
            </select>
        </div>
        <div class="option-group">
            <label for="textSize">Text Size (mm)</label>
            <input type="number" id="textSize" value="30" min="20" max="45" step="1">
        </div>
        <div class="option-group">
            <label for="vectorImage">Upload Vector Image (SVG)</label>
            <input type="file" id="vectorImage" accept=".svg">
        </div>
        <button id="exportBtn">Export as STL</button>
    </div>

    <!-- Three.js Library -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.js",
                "three/addons/": "https://threejs.org/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import CSG from './esm/three-csg.js';

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // Create orthographic camera with suitable frustum for viewing the name sign
        const frustumSize = 120;
        const aspect = (window.innerWidth * 0.66) / window.innerHeight;
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            1,
            1000
        );
        camera.position.set(0, 80, 80);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth * 0.66, window.innerHeight);
        document.getElementById('viewer').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 100, 100);
        scene.add(directionalLight);

        // Add OrbitControls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 50;
        controls.maxDistance = 400;
        controls.maxPolarAngle = Math.PI / 2;

        // CSG function
        function doCSG(a, b, op, mat) {
            a.updateMatrixWorld();
            b.updateMatrixWorld();
            let bspA = CSG.fromMesh(a);
            let bspB = CSG.fromMesh(b);
            let bspC = bspA[op](bspB);
            let result = CSG.toMesh(bspC, a.matrix);
            result.material = mat;
            result.castShadow = result.receiveShadow = true;
            return result;
        }

        // Create baseplate with holes
        function createBaseplateWithHoles(width, height) {
            // Create baseplate
            const baseplate = new THREE.Mesh(
                new THREE.BoxGeometry(width, 1, height),
                new THREE.MeshPhongMaterial({ color: document.getElementById('baseColor').value })
            );

            // Create border
            const borderWidth = 1; // 1mm wide
            const borderHeight = 1; // 1mm high
            const borderOffset = 1; // 1mm offset from edge
            
            // Create border material with its own color
            const borderMaterial = new THREE.MeshPhongMaterial({ 
                color: document.getElementById('borderColor').value 
            });
            
            // Create outer and inner box for the border
            const outerWidth = width - 2 * borderOffset;
            const outerHeight = height - 2 * borderOffset;
            const innerWidth = outerWidth - 2 * borderWidth;
            const innerHeight = outerHeight - 2 * borderWidth;
            
            const outerBox = new THREE.Mesh(
                new THREE.BoxGeometry(outerWidth, borderHeight, outerHeight),
                borderMaterial
            );
            const innerBox = new THREE.Mesh(
                new THREE.BoxGeometry(innerWidth, borderHeight * 1.1, innerHeight),
                borderMaterial
            );
            
            // Position the border on top of the baseplate
            outerBox.position.y = 0.5 + borderHeight/2;
            innerBox.position.y = 0.5 + borderHeight/2;
            
            // Create the border using CSG subtract
            const border = doCSG(outerBox, innerBox, 'subtract', borderMaterial);

            let finalBaseplate = baseplate;
            
            // Only create holes if checkbox is checked
            if (document.getElementById('showHoles').checked) {
                // Create holes
                const holeDiameter = 4; // 4mm diameter holes
                const holeHeight = 4; // Make it thicker to ensure clean cut
                const holeGeometry = new THREE.CylinderGeometry(holeDiameter/2, holeDiameter/2, holeHeight, 64, 1, false);
                const holeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });

                // Create two holes
                const hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
                const hole2 = new THREE.Mesh(holeGeometry, holeMaterial);

                // Position holes
                const holeDistance = parseFloat(document.getElementById('holeSpacing').value);
                hole1.position.set(-holeDistance/2, -holeHeight/4, 0);
                hole2.position.set(holeDistance/2, -holeHeight/4, 0);

                // Update matrices before CSG operation
                baseplate.updateMatrix();
                hole1.updateMatrix();
                hole2.updateMatrix();

                // Perform CSG operations for holes
                const baseplateWithHoles = doCSG(baseplate, hole1, 'subtract', baseplate.material);
                finalBaseplate = doCSG(baseplateWithHoles, hole2, 'subtract', baseplate.material);
            }

            scene.add(finalBaseplate);
            scene.add(border);

            return { baseplate: finalBaseplate, border: border };
        }

        // Initial baseplate creation
        let parts = createBaseplateWithHoles(140, 45);
        let baseplate = parts.baseplate;
        let border = parts.border;

        // Update baseplate when dimensions change
        document.getElementById('baseWidth').addEventListener('input', function() {
            const width = parseFloat(this.value);
            const height = parseFloat(document.getElementById('baseHeight').value);
            scene.remove(baseplate);
            scene.remove(border);
            if (textMesh) scene.remove(textMesh);
            parts = createBaseplateWithHoles(width, height);
            baseplate = parts.baseplate;
            border = parts.border;
            if (currentFont) {
                updateText(currentFont, document.getElementById('signText').value || 'Your Name');
            }
        });

        document.getElementById('baseHeight').addEventListener('input', function() {
            const width = parseFloat(document.getElementById('baseWidth').value);
            const height = parseFloat(this.value);
            scene.remove(baseplate);
            scene.remove(border);
            if (textMesh) scene.remove(textMesh);
            parts = createBaseplateWithHoles(width, height);
            baseplate = parts.baseplate;
            border = parts.border;
            if (currentFont) {
                updateText(currentFont, document.getElementById('signText').value || 'Your Name');
            }
        });

        // Update base color
        document.getElementById('baseColor').addEventListener('change', function() {
            if (baseplate && baseplate.material) {
                baseplate.material.color.set(this.value);
            }
        });

        // Text
        const loader = new FontLoader();
        let textMesh;
        let currentFont = null;
        
        // Font URLs
        const fonts = {
            'helvetiker': 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
            'optimer': 'https://threejs.org/examples/fonts/optimer_regular.typeface.json',
            'gentilis': 'https://threejs.org/examples/fonts/gentilis_regular.typeface.json',
            'droid': 'https://threejs.org/examples/fonts/droid/droid_serif_regular.typeface.json'
        };
        
        // Update font picker options
        const fontPicker = document.getElementById('fontPicker');
        fontPicker.innerHTML = ''; // Clear existing options
        Object.keys(fonts).forEach(fontName => {
            const option = document.createElement('option');
            option.value = fontName;
            option.textContent = fontName.charAt(0).toUpperCase() + fontName.slice(1);
            fontPicker.appendChild(option);
        });

        function updateText(font, text) {
            if (textMesh) {
                scene.remove(textMesh);
                textMesh.geometry.dispose();
            }
            const textSize = parseFloat(document.getElementById('textSize').value) / 5; // Convert mm to units
            const textGeometry = new TextGeometry(text || 'Your Name', {
                font: font,
                size: textSize,
                depth: .1,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.5,
                bevelSize: 0.3,
                bevelSegments: 5
            });
            textGeometry.center();
            const textMaterial = new THREE.MeshPhongMaterial({ 
                color: document.getElementById('borderColor').value 
            });
            textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.y = 1;
            textMesh.rotation.x = -Math.PI / 2;
            scene.add(textMesh);
        }

        // Load initial font
        loader.load(fonts['helvetiker'], function(font) {
            currentFont = font;
            updateText(font, 'Your Name');
        });
        
        // Add text update listener
        document.getElementById('signText').addEventListener('input', function() {
            if (currentFont) {
                updateText(currentFont, this.value);
            }
        });
        
        // Add text size update listener
        document.getElementById('textSize').addEventListener('input', function() {
            if (currentFont) {
                updateText(currentFont, document.getElementById('signText').value || 'Your Name');
            }
        });
        
        // Add font change listener
        document.getElementById('fontPicker').addEventListener('change', function() {
            const selectedFont = this.value;
            loader.load(fonts[selectedFont], function(font) {
                currentFont = font;
                updateText(font, document.getElementById('signText').value || 'Your Name');
            });
        });

        // Vector Image
        let svgMesh;
        document.getElementById('vectorImage').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file && file.name.endsWith('.svg')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const parser = new DOMParser();
                    const svg = parser.parseFromString(e.target.result, 'image/svg+xml').documentElement;

                    const svgData = new XMLSerializer().serializeToString(svg);
                    const texture = new THREE.TextureLoader().load('data:image/svg+xml;base64,' + btoa(svgData));
                    texture.needsUpdate = true;

                    const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                    const geometry = new THREE.PlaneGeometry(20, 20);
                    if (svgMesh) {
                        scene.remove(svgMesh);
                    }
                    svgMesh = new THREE.Mesh(geometry, material);
                    svgMesh.position.y = 3;
                    scene.add(svgMesh);
                };
                reader.readAsText(file);
            }
        });

        // Export Function
        document.getElementById('exportBtn').addEventListener('click', function() {
            const exporter = new OBJExporter();
            
            // Store original rotations
            const originalRotations = new Map();
            scene.traverse((object) => {
                if (object.isMesh) {
                    originalRotations.set(object, object.rotation.x);
                    object.rotation.x += Math.PI/2;
                }
            }); 
            
            // Create a header with material definitions
            let mtlHeader = '';
            const materials = new Set();
            
            scene.traverse((object) => {
                if (object.isMesh && object.material) {
                    const material = object.material;
                    const matName = `material_${material.color.getHexString()}`;
                    if (!materials.has(matName)) {
                        materials.add(matName);
                        mtlHeader += `newmtl ${matName}\n`;
                        mtlHeader += `Kd ${material.color.r} ${material.color.g} ${material.color.b}\n`;
                    }
                    // Assign material name to the mesh
                    object.material.name = matName;
                }
            });
            
            // Export OBJ with materials
            const objData = exporter.parse(scene);
            const finalData = `mtllib name_sign.mtl\n${objData}`;
            
            // Restore original rotations
            scene.traverse((object) => {
                if (object.isMesh) {
                    object.rotation.x = originalRotations.get(object);
                }
            });
            
            // Save OBJ file
            const objBlob = new Blob([finalData], { type: 'text/plain' });
            const objLink = document.createElement('a');
            objLink.href = URL.createObjectURL(objBlob);
            objLink.download = 'name_sign.obj';
            objLink.click();
            
            // Save MTL file
            const mtlBlob = new Blob([mtlHeader], { type: 'text/plain' });
            const mtlLink = document.createElement('a');
            mtlLink.href = URL.createObjectURL(mtlBlob);
            mtlLink.download = 'name_sign.mtl';
            mtlLink.click();
        });

        // Handle Window Resize
        window.addEventListener('resize', function() {
            const viewer = document.getElementById('viewer');
            const width = window.innerWidth * 0.66;
            const height = window.innerHeight;
            const aspect = width / height;
            
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Add border color update listener
        document.getElementById('borderColor').addEventListener('change', function() {
            const color = this.value;
            // Update text color if it exists
            if (textMesh) {
                textMesh.material.color.set(color);
            }
            // Update border color
            if (border && border.material) {
                border.material.color.set(color);
            }
        });

        // Add hole controls listeners
        document.getElementById('showHoles').addEventListener('change', function() {
            const width = parseFloat(document.getElementById('baseWidth').value);
            const height = parseFloat(document.getElementById('baseHeight').value);
            scene.remove(baseplate);
            scene.remove(border);
            if (textMesh) scene.remove(textMesh);
            parts = createBaseplateWithHoles(width, height);
            baseplate = parts.baseplate;
            border = parts.border;
            if (currentFont) {
                updateText(currentFont, document.getElementById('signText').value || 'Your Name');
            }
            // Show/hide hole spacing control based on checkbox
            document.getElementById('holeSpacing').parentElement.style.display = 
                this.checked ? 'block' : 'none';
        });
        
        document.getElementById('holeSpacing').addEventListener('input', function() {
            const width = parseFloat(document.getElementById('baseWidth').value);
            const height = parseFloat(document.getElementById('baseHeight').value);
            scene.remove(baseplate);
            scene.remove(border);
            if (textMesh) scene.remove(textMesh);
            parts = createBaseplateWithHoles(width, height);
            baseplate = parts.baseplate;
            border = parts.border;
            if (currentFont) {
                updateText(currentFont, document.getElementById('signText').value || 'Your Name');
            }
        });
    </script>
</body>
</html>